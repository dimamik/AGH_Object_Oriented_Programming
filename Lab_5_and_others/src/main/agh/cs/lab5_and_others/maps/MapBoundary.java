package agh.cs.lab5_and_others.maps;

import agh.cs.lab5_and_others.movement.Vector2d;
import agh.cs.lab5_and_others.objects.Grass;
import agh.cs.lab5_and_others.objects.IMapElement;

import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;

/**
 * Class is responsible for information about surface
 * taken by objects on map
 * Should contain 2 ordered sets of elements -> 1 over OX, 2 over OY
 * It is all to dynamically have upperRight and LowerLeft corners in 2D
 * Is added as observer to Animal through GrassField
 * Could also be implemented using BTrees, but for now it is just complication
 */
public class MapBoundary implements IPositionChangeObserver {

    private final LinkedList<Vector2d> list_X;
    private final LinkedList<Vector2d> list_Y;
    private final SortByX sortByX;
    private final SortByY sortByY;

    /**
     * Filling the lists with grass (previously generated by GrassField)
     *
     * @param grassHashMap - HashMap of grass
     */
    public MapBoundary(HashMap<Vector2d, Grass> grassHashMap) {
        this.list_X = new LinkedList<>(grassHashMap.keySet());
        this.list_Y = new LinkedList<>(grassHashMap.keySet());
        this.sortByX = new SortByX();
        this.sortByY = new SortByY();

    }

    @Override
    public void positionChanged(IMapElement movedElement, Vector2d oldPosition, Vector2d newPosition) {
        list_X.remove(oldPosition);
        list_Y.remove(oldPosition);
        list_X.add(newPosition);
        list_Y.add(newPosition);
        list_X.sort(sortByX);
        list_Y.sort(sortByY);
    }

    public void positionAdded(IMapElement added_element, Vector2d position) {
        list_X.add(position);
        list_Y.add(position);
        list_X.sort(sortByX);
        list_Y.sort(sortByY);
    }

    /**
     * @return - Upper Right Corner
     */
    public Vector2d getUpper() {
        return new Vector2d(list_X.getLast().getX(), list_Y.getLast().getY());
    }

    /**
     * @return - Lower Left Corner
     */
    public Vector2d getLower() {
        return new Vector2d(list_X.getFirst().getX(), list_Y.getFirst().getY());
    }
}

/**
 * Comparator class to sort by X
 */
class SortByX implements Comparator<Vector2d> {

    @Override
    public int compare(Vector2d o1, Vector2d o2) {
        return o1.getX() - o2.getX();
    }
}

/**
 * Comparator class to sort by Y
 */
class SortByY implements Comparator<Vector2d> {

    @Override
    public int compare(Vector2d o1, Vector2d o2) {
        return o1.getY() - o2.getY();
    }
}